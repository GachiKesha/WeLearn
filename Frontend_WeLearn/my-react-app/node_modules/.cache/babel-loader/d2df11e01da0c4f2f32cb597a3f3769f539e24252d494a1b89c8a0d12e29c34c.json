{"ast":null,"code":"/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function () {\n  return Math.random().toString(36).substring(2, 12);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function (blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function (blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function (blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function (line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n  const candidate = {\n    foundation: parts[0],\n    component: {\n      1: 'rtp',\n      2: 'rtcp'\n    }[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4],\n    // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default:\n        // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function (candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function (line) {\n  return line.substring(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function (line) {\n  let parts = line.substring(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function (codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function (line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n    attributes: parts.slice(2).join(' ')\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function (headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function (line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substring(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function (codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function (line) {\n  const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function (codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function (line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substring(7, sp), 10)\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substring(sp + 1, colon);\n    parts.value = line.substring(colon + 1);\n  } else {\n    parts.attribute = line.substring(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function (line) {\n  const parts = line.substring(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function (mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substring(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function (line) {\n  const parts = line.substring(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(),\n    // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function (params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function (line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3)\n  };\n};\nSDPUtils.writeCryptoLine = function (parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function (keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substring(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n  };\n};\nSDPUtils.writeCryptoKeyParams = function (keyParams) {\n  return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substring(12),\n    password: pwd.substring(10)\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function (params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function (mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  description.profile = mline[2];\n  for (let i = 3; i < mline.length; i++) {\n    // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default:\n          // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\n  description.codecs.forEach(codec => {\n    wildcardRtcpFb.forEach(fb => {\n      const duplicate = codec.rtcpFeedback.find(existingFeedback => {\n        return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n      });\n      if (!duplicate) {\n        codec.rtcpFeedback.push(fb);\n      }\n    });\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function (kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\n    const parts = line.substring(17).split(' ');\n    return parts.map(part => parseInt(part, 10));\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {\n          ssrc: secondarySsrc\n        };\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substring(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function (mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n  return rtcpParameters;\n};\nSDPUtils.writeRtcpParameters = function (rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function (mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substring(7).split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function (mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substring(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0].substring(10).split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function (media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\n  } else {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function () {\n  return Math.random().toString().substr(2, 22);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function (mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substring(2);\n      default:\n      // FIXME: What should happen here?\n    }\n  }\n\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\nSDPUtils.getKind = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substring(2);\n};\nSDPUtils.isRejected = function (mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\nSDPUtils.parseMLine = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substring(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\nSDPUtils.parseOLine = function (mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substring(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function (blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}","map":{"version":3,"names":["SDPUtils","generateIdentifier","Math","random","toString","substring","localCName","splitLines","blob","trim","split","map","line","splitSections","parts","part","index","getDescription","sections","getMediaSections","shift","matchPrefix","prefix","filter","indexOf","parseCandidate","candidate","foundation","component","protocol","toLowerCase","priority","parseInt","ip","address","port","type","i","length","relatedAddress","relatedPort","tcpType","ufrag","usernameFragment","undefined","writeCandidate","sdp","push","toUpperCase","join","parseIceOptions","parseRtpMap","parsed","payloadType","name","clockRate","channels","numChannels","writeRtpMap","codec","pt","preferredPayloadType","parseExtmap","id","direction","uri","attributes","slice","writeExtmap","headerExtension","preferredId","parseFmtp","kv","j","writeFmtp","parameters","Object","keys","params","forEach","param","parseRtcpFb","parameter","writeRtcpFb","lines","rtcpFeedback","fb","parseSsrcMedia","sp","ssrc","colon","attribute","value","parseSsrcGroup","semantics","ssrcs","getMid","mediaSection","mid","parseFingerprint","algorithm","getDtlsParameters","sessionpart","role","fingerprints","writeDtlsParameters","setupType","fp","parseCryptoLine","tag","cryptoSuite","keyParams","sessionParams","writeCryptoLine","writeCryptoKeyParams","parseCryptoKeyParams","keyMethod","keySalt","lifeTime","mkiValue","mkiLength","getCryptoParameters","getIceParameters","pwd","password","writeIceParameters","iceLite","parseRtpParameters","description","codecs","headerExtensions","fecMechanisms","rtcp","mline","profile","rtpmapline","fmtps","wildcardRtcpFb","duplicate","find","existingFeedback","writeRtpDescription","kind","caps","maxptime","extension","parseRtpEncodingParameters","encodingParameters","hasRed","hasUlpfec","primarySsrc","secondarySsrc","flows","apt","encParam","codecPayloadType","rtx","JSON","parse","stringify","fec","mechanism","bandwidth","maxBitrate","parseRtcpParameters","rtcpParameters","remoteSsrc","obj","cname","rsize","reducedSize","compound","mux","writeRtcpParameters","parseMsid","spec","stream","track","planB","msidParts","parseSctpDescription","parseMLine","maxSizeLine","maxMessageSize","isNaN","sctpPort","fmt","sctpMapLines","writeSctpDescription","media","sctp","output","generateSessionId","substr","writeSessionBoilerplate","sessId","sessVer","sessUser","sessionId","version","user","getDirection","getKind","isRejected","parseOLine","username","sessionVersion","netType","addressType","isValidSDP","charAt","module","exports"],"sources":["C:/Users/Катя/Desktop/WeLearn/Frontend_WeLearn/node_modules/sdp/sdp.js"],"sourcesContent":["/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substring(2, 12);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ?\n    'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function(line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7],\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function(candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substring(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  let parts = line.substring(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10), // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n    attributes: parts.slice(2).join(' '),\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri +\n      (headerExtension.attributes ? ' ' + headerExtension.attributes : '') +\n      '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substring(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' '),\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substring(7, sp), 10),\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substring(sp + 1, colon);\n    parts.value = line.substring(colon + 1);\n  } else {\n    parts.attribute = line.substring(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function(line) {\n  const parts = line.substring(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substring(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function(line) {\n  const parts = line.substring(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint),\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substring(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substring(12),\n    password: pwd.substring(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: [],\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  description.profile = mline[2];\n  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ')\n    .map(SDPUtils.parseRtcpFb);\n  description.codecs.forEach(codec => {\n    wildcardRtcpFb.forEach(fb=> {\n      const duplicate = codec.rtcpFeedback.find(existingFeedback => {\n        return existingFeedback.type === fb.type &&\n          existingFeedback.parameter === fb.parameter;\n      });\n      if (!duplicate) {\n        codec.rtcpFeedback.push(fb);\n      }\n    });\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(line => {\n      const parts = line.substring(17).split(' ');\n      return parts.map(part => parseInt(part, 10));\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc,\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substring(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function(rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc +\n      ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substring(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substring(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize,\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0]\n      .substring(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize,\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n',\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n',\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 22);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substring(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substring(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substring(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' '),\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substring(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}