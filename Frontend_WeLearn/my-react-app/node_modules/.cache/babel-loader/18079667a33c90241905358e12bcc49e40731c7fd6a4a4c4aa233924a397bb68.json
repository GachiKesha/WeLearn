{"ast":null,"code":"import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */function () {\n  function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n    if (maxKeyLength === void 0) {\n      maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n    }\n    if (maxLengthPerKey === void 0) {\n      maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n    }\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n    this.hit = 0;\n    this.miss = 0;\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (var i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n  CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  };\n  CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n    var records = this.caches[byteLength - 1];\n    FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n      var record = records_1[_i];\n      var recordBytes = record.bytes;\n      for (var j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  };\n  CachedKeyDecoder.prototype.store = function (bytes, value) {\n    var records = this.caches[bytes.length - 1];\n    var record = {\n      bytes: bytes,\n      str: value\n    };\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[Math.random() * records.length | 0] = record;\n    } else {\n      records.push(record);\n    }\n  };\n  CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n    var cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n    var str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  };\n  return CachedKeyDecoder;\n}();\nexport { CachedKeyDecoder };","map":{"version":3,"names":["utf8DecodeJs","DEFAULT_MAX_KEY_LENGTH","DEFAULT_MAX_LENGTH_PER_KEY","CachedKeyDecoder","maxKeyLength","maxLengthPerKey","hit","miss","caches","i","push","prototype","canBeCached","byteLength","find","bytes","inputOffset","records","FIND_CHUNK","_i","records_1","length","record","recordBytes","j","str","store","value","Math","random","decode","cachedValue","slicedCopyOfBytes","Uint8Array","slice","call"],"sources":["C:\\Users\\Катя\\Desktop\\WeLearn\\Frontend_WeLearn\\node_modules\\@msgpack\\msgpack\\src\\CachedKeyDecoder.ts"],"sourcesContent":["import { utf8DecodeJs } from \"./utils/utf8\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}