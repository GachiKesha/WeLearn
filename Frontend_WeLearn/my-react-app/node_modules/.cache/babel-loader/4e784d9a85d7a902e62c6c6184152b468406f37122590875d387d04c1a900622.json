{"ast":null,"code":"import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js';\nlet textEncoder;\ntry {\n  textEncoder = new TextEncoder();\n} catch (error) {}\nlet extensions, extensionClasses;\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined';\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array;\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array;\nconst MAX_STRUCTURES = 0x100;\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000;\nlet serializationId = 1;\nlet throwOnIterable;\nlet target;\nlet targetView;\nlet position = 0;\nlet safeEnd;\nlet bundledStrings = null;\nconst MAX_BUNDLE_SIZE = 0xf000;\nconst hasNonLatin = /[\\u0080-\\uFFFF]/;\nconst RECORD_SYMBOL = Symbol('record-id');\nexport class Encoder extends Decoder {\n  constructor(options) {\n    super(options);\n    this.offset = 0;\n    let typeBuffer;\n    let start;\n    let sharedStructures;\n    let hasSharedUpdate;\n    let structures;\n    let referenceMap;\n    options = options || {};\n    let encodeUtf8 = ByteArray.prototype.utf8Write ? function (string, position, maxBytes) {\n      return target.utf8Write(string, position, maxBytes);\n    } : textEncoder && textEncoder.encodeInto ? function (string, position) {\n      return textEncoder.encodeInto(string, target.subarray(position)).written;\n    } : false;\n    let encoder = this;\n    let hasSharedStructures = options.structures || options.saveStructures;\n    let maxSharedStructures = options.maxSharedStructures;\n    if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 128 : 0;\n    if (maxSharedStructures > 8190) throw new Error('Maximum maxSharedStructure is 8190');\n    let isSequential = options.sequential;\n    if (isSequential) {\n      maxSharedStructures = 0;\n    }\n    if (!this.structures) this.structures = [];\n    if (this.saveStructures) this.saveShared = this.saveStructures;\n    let samplingPackedValues,\n      packedObjectMap,\n      sharedValues = options.sharedValues;\n    let sharedPackedObjectMap;\n    if (sharedValues) {\n      sharedPackedObjectMap = Object.create(null);\n      for (let i = 0, l = sharedValues.length; i < l; i++) {\n        sharedPackedObjectMap[sharedValues[i]] = i;\n      }\n    }\n    let recordIdsToRemove = [];\n    let transitionsCount = 0;\n    let serializationsSinceTransitionRebuild = 0;\n    this.mapEncode = function (value, encodeOptions) {\n      // Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n      if (this._keyMap && !this._mapped) {\n        //console.log('encoding ', value)\n        switch (value.constructor.name) {\n          case 'Array':\n            value = value.map(r => this.encodeKeys(r));\n            break;\n          //case 'Map': \n          //\tvalue = this.encodeKeys(value)\n          //\tbreak\n        }\n        //this._mapped = true\n      }\n\n      return this.encode(value, encodeOptions);\n    };\n    this.encode = function (value, encodeOptions) {\n      if (!target) {\n        target = new ByteArrayAllocate(8192);\n        targetView = new DataView(target.buffer, 0, 8192);\n        position = 0;\n      }\n      safeEnd = target.length - 10;\n      if (safeEnd - position < 0x800) {\n        // don't start too close to the end, \n        target = new ByteArrayAllocate(target.length);\n        targetView = new DataView(target.buffer, 0, target.length);\n        safeEnd = target.length - 10;\n        position = 0;\n      } else if (encodeOptions === REUSE_BUFFER_MODE) position = position + 7 & 0x7ffffff8; // Word align to make any future copying of this buffer faster\n      start = position;\n      if (encoder.useSelfDescribedHeader) {\n        targetView.setUint32(position, 0xd9d9f700); // tag two byte, then self-descriptive tag\n        position += 3;\n      }\n      referenceMap = encoder.structuredClone ? new Map() : null;\n      if (encoder.bundleStrings && typeof value !== 'string') {\n        bundledStrings = [];\n        bundledStrings.size = Infinity; // force a new bundle start on first string\n      } else bundledStrings = null;\n      sharedStructures = encoder.structures;\n      if (sharedStructures) {\n        if (sharedStructures.uninitialized) {\n          let sharedData = encoder.getShared() || {};\n          encoder.structures = sharedStructures = sharedData.structures || [];\n          encoder.sharedVersion = sharedData.version;\n          let sharedValues = encoder.sharedValues = sharedData.packedValues;\n          if (sharedValues) {\n            sharedPackedObjectMap = {};\n            for (let i = 0, l = sharedValues.length; i < l; i++) sharedPackedObjectMap[sharedValues[i]] = i;\n          }\n        }\n        let sharedStructuresLength = sharedStructures.length;\n        if (sharedStructuresLength > maxSharedStructures && !isSequential) sharedStructuresLength = maxSharedStructures;\n        if (!sharedStructures.transitions) {\n          // rebuild our structure transitions\n          sharedStructures.transitions = Object.create(null);\n          for (let i = 0; i < sharedStructuresLength; i++) {\n            let keys = sharedStructures[i];\n            //console.log('shared struct keys:', keys)\n            if (!keys) continue;\n            let nextTransition,\n              transition = sharedStructures.transitions;\n            for (let j = 0, l = keys.length; j < l; j++) {\n              if (transition[RECORD_SYMBOL] === undefined) transition[RECORD_SYMBOL] = i;\n              let key = keys[j];\n              nextTransition = transition[key];\n              if (!nextTransition) {\n                nextTransition = transition[key] = Object.create(null);\n              }\n              transition = nextTransition;\n            }\n            transition[RECORD_SYMBOL] = i | 0x100000;\n          }\n        }\n        if (!isSequential) sharedStructures.nextId = sharedStructuresLength;\n      }\n      if (hasSharedUpdate) hasSharedUpdate = false;\n      structures = sharedStructures || [];\n      packedObjectMap = sharedPackedObjectMap;\n      if (options.pack) {\n        let packedValues = new Map();\n        packedValues.values = [];\n        packedValues.encoder = encoder;\n        packedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity);\n        packedValues.objectMap = sharedPackedObjectMap || false;\n        packedValues.samplingPackedValues = samplingPackedValues;\n        findRepetitiveStrings(value, packedValues);\n        if (packedValues.values.length > 0) {\n          target[position++] = 0xd8; // one-byte tag\n          target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n          writeArrayHeader(4);\n          let valuesArray = packedValues.values;\n          encode(valuesArray);\n          writeArrayHeader(0); // prefixes\n          writeArrayHeader(0); // suffixes\n          packedObjectMap = Object.create(sharedPackedObjectMap || null);\n          for (let i = 0, l = valuesArray.length; i < l; i++) {\n            packedObjectMap[valuesArray[i]] = i;\n          }\n        }\n      }\n      throwOnIterable = encodeOptions & THROW_ON_ITERABLE;\n      try {\n        if (throwOnIterable) return;\n        encode(value);\n        if (bundledStrings) {\n          writeBundles(start, encode);\n        }\n        encoder.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n        if (referenceMap && referenceMap.idsToInsert) {\n          position += referenceMap.idsToInsert.length * 2;\n          if (position > safeEnd) makeRoom(position);\n          encoder.offset = position;\n          let serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert);\n          referenceMap = null;\n          return serialized;\n        }\n        if (encodeOptions & REUSE_BUFFER_MODE) {\n          target.start = start;\n          target.end = position;\n          return target;\n        }\n        return target.subarray(start, position); // position can change if we call encode again in saveShared, so we get the buffer now\n      } finally {\n        if (sharedStructures) {\n          if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;\n          if (sharedStructures.length > maxSharedStructures) sharedStructures.length = maxSharedStructures;\n          if (transitionsCount > 10000) {\n            // force a rebuild occasionally after a lot of transitions so it can get cleaned up\n            sharedStructures.transitions = null;\n            serializationsSinceTransitionRebuild = 0;\n            transitionsCount = 0;\n            if (recordIdsToRemove.length > 0) recordIdsToRemove = [];\n          } else if (recordIdsToRemove.length > 0 && !isSequential) {\n            for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n              recordIdsToRemove[i][RECORD_SYMBOL] = undefined;\n            }\n            recordIdsToRemove = [];\n            //sharedStructures.nextId = maxSharedStructures\n          }\n        }\n\n        if (hasSharedUpdate && encoder.saveShared) {\n          if (encoder.structures.length > maxSharedStructures) {\n            encoder.structures = encoder.structures.slice(0, maxSharedStructures);\n          }\n          // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n          let returnBuffer = target.subarray(start, position);\n          if (encoder.updateSharedData() === false) return encoder.encode(value); // re-encode if it fails\n          return returnBuffer;\n        }\n        if (encodeOptions & RESET_BUFFER_MODE) position = start;\n      }\n    };\n    this.findCommonStringsToPack = () => {\n      samplingPackedValues = new Map();\n      if (!sharedPackedObjectMap) sharedPackedObjectMap = Object.create(null);\n      return options => {\n        let threshold = options && options.threshold || 4;\n        let position = this.pack ? options.maxPrivatePackedValues || 16 : 0;\n        if (!sharedValues) sharedValues = this.sharedValues = [];\n        for (let [key, status] of samplingPackedValues) {\n          if (status.count > threshold) {\n            sharedPackedObjectMap[key] = position++;\n            sharedValues.push(key);\n            hasSharedUpdate = true;\n          }\n        }\n        while (this.saveShared && this.updateSharedData() === false) {}\n        samplingPackedValues = null;\n      };\n    };\n    const encode = value => {\n      if (position > safeEnd) target = makeRoom(position);\n      var type = typeof value;\n      var length;\n      if (type === 'string') {\n        if (packedObjectMap) {\n          let packedPosition = packedObjectMap[value];\n          if (packedPosition >= 0) {\n            if (packedPosition < 16) target[position++] = packedPosition + 0xe0; // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n            else {\n              target[position++] = 0xc6; // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n              if (packedPosition & 1) encode(15 - packedPosition >> 1);else encode(packedPosition - 16 >> 1);\n            }\n            return;\n            /*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n            \t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n            \t\t\t\t\t\t\tpackedStatus.count = 1\n            \t\t\t\t\t\t\tif (options.sharedPack) {\n            \t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n            \t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n            \t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n            \t\t\t\t\t\t\t\t\thasSharedUpdate = true\n            \t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n            \t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n            \n            \t\t\t\t\t\t\t\t}\n            \t\t\t\t\t\t\t}\n            \t\t\t\t\t\t} // else any in-doc incrementation?*/\n          } else if (samplingPackedValues && !options.pack) {\n            let status = samplingPackedValues.get(value);\n            if (status) status.count++;else samplingPackedValues.set(value, {\n              count: 1\n            });\n          }\n        }\n        let strLength = value.length;\n        if (bundledStrings && strLength >= 4 && strLength < 0x400) {\n          if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n            let extStart;\n            let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;\n            if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n            target[position++] = 0xd9; // tag 16-bit\n            target[position++] = 0xdf; // tag 0xdff9\n            target[position++] = 0xf9;\n            // TODO: If we only have one bundle with any string data, only write one string bundle\n            target[position++] = bundledStrings.position ? 0x84 : 0x82; // array of 4 or 2 elements depending on if we write bundles\n            target[position++] = 0x1a; // 32-bit unsigned int\n            extStart = position - start;\n            position += 4; // reserve for writing bundle reference\n            if (bundledStrings.position) {\n              writeBundles(start, encode); // write the last bundles\n            }\n\n            bundledStrings = ['', '']; // create new ones\n            bundledStrings.size = 0;\n            bundledStrings.position = extStart;\n          }\n          let twoByte = hasNonLatin.test(value);\n          bundledStrings[twoByte ? 0 : 1] += value;\n          target[position++] = twoByte ? 0xce : 0xcf;\n          encode(strLength);\n          return;\n        }\n        let headerSize;\n        // first we estimate the header size, so we can write to the correct location\n        if (strLength < 0x20) {\n          headerSize = 1;\n        } else if (strLength < 0x100) {\n          headerSize = 2;\n        } else if (strLength < 0x10000) {\n          headerSize = 3;\n        } else {\n          headerSize = 5;\n        }\n        let maxBytes = strLength * 3;\n        if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n        if (strLength < 0x40 || !encodeUtf8) {\n          let i,\n            c1,\n            c2,\n            strPosition = position + headerSize;\n          for (i = 0; i < strLength; i++) {\n            c1 = value.charCodeAt(i);\n            if (c1 < 0x80) {\n              target[strPosition++] = c1;\n            } else if (c1 < 0x800) {\n              target[strPosition++] = c1 >> 6 | 0xc0;\n              target[strPosition++] = c1 & 0x3f | 0x80;\n            } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n              c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n              i++;\n              target[strPosition++] = c1 >> 18 | 0xf0;\n              target[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n              target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n              target[strPosition++] = c1 & 0x3f | 0x80;\n            } else {\n              target[strPosition++] = c1 >> 12 | 0xe0;\n              target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n              target[strPosition++] = c1 & 0x3f | 0x80;\n            }\n          }\n          length = strPosition - position - headerSize;\n        } else {\n          length = encodeUtf8(value, position + headerSize, maxBytes);\n        }\n        if (length < 0x18) {\n          target[position++] = 0x60 | length;\n        } else if (length < 0x100) {\n          if (headerSize < 2) {\n            target.copyWithin(position + 2, position + 1, position + 1 + length);\n          }\n          target[position++] = 0x78;\n          target[position++] = length;\n        } else if (length < 0x10000) {\n          if (headerSize < 3) {\n            target.copyWithin(position + 3, position + 2, position + 2 + length);\n          }\n          target[position++] = 0x79;\n          target[position++] = length >> 8;\n          target[position++] = length & 0xff;\n        } else {\n          if (headerSize < 5) {\n            target.copyWithin(position + 5, position + 3, position + 3 + length);\n          }\n          target[position++] = 0x7a;\n          targetView.setUint32(position, length);\n          position += 4;\n        }\n        position += length;\n      } else if (type === 'number') {\n        if (!this.alwaysUseFloat && value >>> 0 === value) {\n          // positive integer, 32-bit or less\n          // positive uint\n          if (value < 0x18) {\n            target[position++] = value;\n          } else if (value < 0x100) {\n            target[position++] = 0x18;\n            target[position++] = value;\n          } else if (value < 0x10000) {\n            target[position++] = 0x19;\n            target[position++] = value >> 8;\n            target[position++] = value & 0xff;\n          } else {\n            target[position++] = 0x1a;\n            targetView.setUint32(position, value);\n            position += 4;\n          }\n        } else if (!this.alwaysUseFloat && value >> 0 === value) {\n          // negative integer\n          if (value >= -0x18) {\n            target[position++] = 0x1f - value;\n          } else if (value >= -0x100) {\n            target[position++] = 0x38;\n            target[position++] = ~value;\n          } else if (value >= -0x10000) {\n            target[position++] = 0x39;\n            targetView.setUint16(position, ~value);\n            position += 2;\n          } else {\n            target[position++] = 0x3a;\n            targetView.setUint32(position, ~value);\n            position += 4;\n          }\n        } else {\n          let useFloat32;\n          if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n            target[position++] = 0xfa;\n            targetView.setFloat32(position, value);\n            let xShifted;\n            if (useFloat32 < 4 ||\n            // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n            (xShifted = value * mult10[(target[position] & 0x7f) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {\n              position += 4;\n              return;\n            } else position--; // move back into position for writing a double\n          }\n\n          target[position++] = 0xfb;\n          targetView.setFloat64(position, value);\n          position += 8;\n        }\n      } else if (type === 'object') {\n        if (!value) target[position++] = 0xf6;else {\n          if (referenceMap) {\n            let referee = referenceMap.get(value);\n            if (referee) {\n              target[position++] = 0xd8;\n              target[position++] = 29; // http://cbor.schmorp.de/value-sharing\n              target[position++] = 0x19; // 16-bit uint\n              if (!referee.references) {\n                let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n                referee.references = [];\n                idsToInsert.push(referee);\n              }\n              referee.references.push(position - start);\n              position += 2; // TODO: also support 32-bit\n              return;\n            } else referenceMap.set(value, {\n              offset: position - start\n            });\n          }\n          let constructor = value.constructor;\n          if (constructor === Object) {\n            writeObject(value, true);\n          } else if (constructor === Array) {\n            length = value.length;\n            if (length < 0x18) {\n              target[position++] = 0x80 | length;\n            } else {\n              writeArrayHeader(length);\n            }\n            for (let i = 0; i < length; i++) {\n              encode(value[i]);\n            }\n          } else if (constructor === Map) {\n            if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n              // use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n              target[position++] = 0xd9;\n              target[position++] = 1;\n              target[position++] = 3;\n            }\n            length = value.size;\n            if (length < 0x18) {\n              target[position++] = 0xa0 | length;\n            } else if (length < 0x100) {\n              target[position++] = 0xb8;\n              target[position++] = length;\n            } else if (length < 0x10000) {\n              target[position++] = 0xb9;\n              target[position++] = length >> 8;\n              target[position++] = length & 0xff;\n            } else {\n              target[position++] = 0xba;\n              targetView.setUint32(position, length);\n              position += 4;\n            }\n            if (encoder.keyMap) {\n              for (let [key, entryValue] of value) {\n                encode(encoder.encodeKey(key));\n                encode(entryValue);\n              }\n            } else {\n              for (let [key, entryValue] of value) {\n                encode(key);\n                encode(entryValue);\n              }\n            }\n          } else {\n            for (let i = 0, l = extensions.length; i < l; i++) {\n              let extensionClass = extensionClasses[i];\n              if (value instanceof extensionClass) {\n                let extension = extensions[i];\n                let tag = extension.tag;\n                if (tag == undefined) tag = extension.getTag && extension.getTag.call(this, value);\n                if (tag < 0x18) {\n                  target[position++] = 0xc0 | tag;\n                } else if (tag < 0x100) {\n                  target[position++] = 0xd8;\n                  target[position++] = tag;\n                } else if (tag < 0x10000) {\n                  target[position++] = 0xd9;\n                  target[position++] = tag >> 8;\n                  target[position++] = tag & 0xff;\n                } else if (tag > -1) {\n                  target[position++] = 0xda;\n                  targetView.setUint32(position, tag);\n                  position += 4;\n                } // else undefined, don't write tag\n                extension.encode.call(this, value, encode, makeRoom);\n                return;\n              }\n            }\n            if (value[Symbol.iterator]) {\n              if (throwOnIterable) {\n                let error = new Error('Iterable should be serialized as iterator');\n                error.iteratorNotHandled = true;\n                throw error;\n              }\n              target[position++] = 0x9f; // indefinite length array\n              for (let entry of value) {\n                encode(entry);\n              }\n              target[position++] = 0xff; // stop-code\n              return;\n            }\n            if (value[Symbol.asyncIterator] || isBlob(value)) {\n              let error = new Error('Iterable/blob should be serialized as iterator');\n              error.iteratorNotHandled = true;\n              throw error;\n            }\n            if (this.useToJSON && value.toJSON) {\n              const json = value.toJSON();\n              // if for some reason value.toJSON returns itself it'll loop forever\n              if (json !== value) return encode(json);\n            }\n\n            // no extension found, write as object\n            writeObject(value, !value.hasOwnProperty); // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n          }\n        }\n      } else if (type === 'boolean') {\n        target[position++] = value ? 0xf5 : 0xf4;\n      } else if (type === 'bigint') {\n        if (value < BigInt(1) << BigInt(64) && value >= 0) {\n          // use an unsigned int as long as it fits\n          target[position++] = 0x1b;\n          targetView.setBigUint64(position, value);\n        } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {\n          // if we can fit an unsigned int, use that\n          target[position++] = 0x3b;\n          targetView.setBigUint64(position, -value - BigInt(1));\n        } else {\n          // overflow\n          if (this.largeBigIntToFloat) {\n            target[position++] = 0xfb;\n            targetView.setFloat64(position, Number(value));\n          } else {\n            throw new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64');\n          }\n        }\n        position += 8;\n      } else if (type === 'undefined') {\n        target[position++] = 0xf7;\n      } else {\n        throw new Error('Unknown type: ' + type);\n      }\n    };\n    const writeObject = this.useRecords === false ? this.variableMapSize ? object => {\n      // this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n      let keys = Object.keys(object);\n      let vals = Object.values(object);\n      let length = keys.length;\n      if (length < 0x18) {\n        target[position++] = 0xa0 | length;\n      } else if (length < 0x100) {\n        target[position++] = 0xb8;\n        target[position++] = length;\n      } else if (length < 0x10000) {\n        target[position++] = 0xb9;\n        target[position++] = length >> 8;\n        target[position++] = length & 0xff;\n      } else {\n        target[position++] = 0xba;\n        targetView.setUint32(position, length);\n        position += 4;\n      }\n      let key;\n      if (encoder.keyMap) {\n        for (let i = 0; i < length; i++) {\n          encode(encoder.encodeKey(keys[i]));\n          encode(vals[i]);\n        }\n      } else {\n        for (let i = 0; i < length; i++) {\n          encode(keys[i]);\n          encode(vals[i]);\n        }\n      }\n    } : (object, safePrototype) => {\n      target[position++] = 0xb9; // always use map 16, so we can preallocate and set the length afterwards\n      let objectOffset = position - start;\n      position += 2;\n      let size = 0;\n      if (encoder.keyMap) {\n        for (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n          encode(encoder.encodeKey(key));\n          encode(object[key]);\n          size++;\n        }\n      } else {\n        for (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n          encode(key);\n          encode(object[key]);\n          size++;\n        }\n      }\n      target[objectOffset++ + start] = size >> 8;\n      target[objectOffset + start] = size & 0xff;\n    } : (object, safePrototype) => {\n      let nextTransition,\n        transition = structures.transitions || (structures.transitions = Object.create(null));\n      let newTransitions = 0;\n      let length = 0;\n      let parentRecordId;\n      let keys;\n      if (this.keyMap) {\n        keys = Object.keys(object).map(k => this.encodeKey(k));\n        length = keys.length;\n        for (let i = 0; i < length; i++) {\n          let key = keys[i];\n          nextTransition = transition[key];\n          if (!nextTransition) {\n            nextTransition = transition[key] = Object.create(null);\n            newTransitions++;\n          }\n          transition = nextTransition;\n        }\n      } else {\n        for (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n          nextTransition = transition[key];\n          if (!nextTransition) {\n            if (transition[RECORD_SYMBOL] & 0x100000) {\n              // this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n              parentRecordId = transition[RECORD_SYMBOL] & 0xffff;\n            }\n            nextTransition = transition[key] = Object.create(null);\n            newTransitions++;\n          }\n          transition = nextTransition;\n          length++;\n        }\n      }\n      let recordId = transition[RECORD_SYMBOL];\n      if (recordId !== undefined) {\n        recordId &= 0xffff;\n        target[position++] = 0xd9;\n        target[position++] = recordId >> 8 | 0xe0;\n        target[position++] = recordId & 0xff;\n      } else {\n        if (!keys) keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));\n        if (parentRecordId === undefined) {\n          recordId = structures.nextId++;\n          if (!recordId) {\n            recordId = 0;\n            structures.nextId = 1;\n          }\n          if (recordId >= MAX_STRUCTURES) {\n            // cycle back around\n            structures.nextId = (recordId = maxSharedStructures) + 1;\n          }\n        } else {\n          recordId = parentRecordId;\n        }\n        structures[recordId] = keys;\n        if (recordId < maxSharedStructures) {\n          target[position++] = 0xd9;\n          target[position++] = recordId >> 8 | 0xe0;\n          target[position++] = recordId & 0xff;\n          transition = structures.transitions;\n          for (let i = 0; i < length; i++) {\n            if (transition[RECORD_SYMBOL] === undefined || transition[RECORD_SYMBOL] & 0x100000) transition[RECORD_SYMBOL] = recordId;\n            transition = transition[keys[i]];\n          }\n          transition[RECORD_SYMBOL] = recordId | 0x100000; // indicates it is a extendable terminal\n          hasSharedUpdate = true;\n        } else {\n          transition[RECORD_SYMBOL] = recordId;\n          targetView.setUint32(position, 0xd9dfff00); // tag two byte, then record definition id\n          position += 3;\n          if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n          // record the removal of the id, we can maintain our shared structure\n          if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures) recordIdsToRemove.shift()[RECORD_SYMBOL] = undefined; // we are cycling back through, and have to remove old ones\n          recordIdsToRemove.push(transition);\n          writeArrayHeader(length + 2);\n          encode(0xe000 + recordId);\n          encode(keys);\n          if (safePrototype === null) return; // special exit for iterator\n          for (let key in object) if (safePrototype || object.hasOwnProperty(key)) encode(object[key]);\n          return;\n        }\n      }\n      if (length < 0x18) {\n        // write the array header\n        target[position++] = 0x80 | length;\n      } else {\n        writeArrayHeader(length);\n      }\n      if (safePrototype === null) return; // special exit for iterator\n      for (let key in object) if (safePrototype || object.hasOwnProperty(key)) encode(object[key]);\n    };\n    const makeRoom = end => {\n      let newSize;\n      if (end > 0x1000000) {\n        // special handling for really large buffers\n        if (end - start > MAX_BUFFER_SIZE) throw new Error('Encoded buffer would be larger than maximum buffer size');\n        newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n      } else\n        // faster handling for smaller buffers\n        newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;\n      let newBuffer = new ByteArrayAllocate(newSize);\n      targetView = new DataView(newBuffer.buffer, 0, newSize);\n      if (target.copy) target.copy(newBuffer, 0, start, end);else newBuffer.set(target.slice(start, end));\n      position -= start;\n      start = 0;\n      safeEnd = newBuffer.length - 10;\n      return target = newBuffer;\n    };\n    let chunkThreshold = 100;\n    let continuedChunkThreshold = 1000;\n    this.encodeAsIterable = function (value, options) {\n      return startEncoding(value, options, encodeObjectAsIterable);\n    };\n    this.encodeAsAsyncIterable = function (value, options) {\n      return startEncoding(value, options, encodeObjectAsAsyncIterable);\n    };\n    function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n      let constructor = object.constructor;\n      if (constructor === Object) {\n        let useRecords = encoder.useRecords !== false;\n        if (useRecords) writeObject(object, null); // write the record identifier\n        else writeEntityLength(Object.keys(object).length, 0xa0);\n        for (let key in object) {\n          let value = object[key];\n          if (!useRecords) encode(key);\n          if (value && typeof value === 'object') {\n            if (iterateProperties[key]) yield* encodeObjectAsIterable(value, iterateProperties[key]);else yield* tryEncode(value, iterateProperties, key);\n          } else encode(value);\n        }\n      } else if (constructor === Array) {\n        let length = object.length;\n        writeArrayHeader(length);\n        for (let i = 0; i < length; i++) {\n          let value = object[i];\n          if (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n            if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);else yield* tryEncode(value, iterateProperties, 'element');\n          } else encode(value);\n        }\n      } else if (object[Symbol.iterator]) {\n        target[position++] = 0x9f; // start indefinite array\n        for (let value of object) {\n          if (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n            if (iterateProperties.element) yield* encodeObjectAsIterable(value, iterateProperties.element);else yield* tryEncode(value, iterateProperties, 'element');\n          } else encode(value);\n        }\n        target[position++] = 0xff; // stop byte\n      } else if (isBlob(object)) {\n        writeEntityLength(object.size, 0x40); // encode as binary data\n        yield target.subarray(start, position);\n        yield object; // directly return blobs, they have to be encoded asynchronously\n        restartEncoding();\n      } else if (object[Symbol.asyncIterator]) {\n        target[position++] = 0x9f; // start indefinite array\n        yield target.subarray(start, position);\n        yield object; // directly return async iterators, they have to be encoded asynchronously\n        restartEncoding();\n        target[position++] = 0xff; // stop byte\n      } else {\n        encode(object);\n      }\n      if (finalIterable && position > start) yield target.subarray(start, position);else if (position - start > chunkThreshold) {\n        yield target.subarray(start, position);\n        restartEncoding();\n      }\n    }\n    function* tryEncode(value, iterateProperties, key) {\n      let restart = position - start;\n      try {\n        encode(value);\n        if (position - start > chunkThreshold) {\n          yield target.subarray(start, position);\n          restartEncoding();\n        }\n      } catch (error) {\n        if (error.iteratorNotHandled) {\n          iterateProperties[key] = {};\n          position = start + restart; // restart our position so we don't have partial data from last encode\n          yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n        } else throw error;\n      }\n    }\n    function restartEncoding() {\n      chunkThreshold = continuedChunkThreshold;\n      encoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n    }\n\n    function startEncoding(value, options, encodeIterable) {\n      if (options && options.chunkThreshold)\n        // explicitly specified chunk sizes\n        chunkThreshold = continuedChunkThreshold = options.chunkThreshold;else\n        // we start with a smaller threshold to get initial bytes sent quickly\n        chunkThreshold = 100;\n      if (value && typeof value === 'object') {\n        encoder.encode(null, THROW_ON_ITERABLE); // start encoding\n        return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n      }\n      return [encoder.encode(value)];\n    }\n    async function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n      for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n        let constructor = encodedValue.constructor;\n        if (constructor === ByteArray || constructor === Uint8Array) yield encodedValue;else if (isBlob(encodedValue)) {\n          let reader = encodedValue.stream().getReader();\n          let next;\n          while (!(next = await reader.read()).done) {\n            yield next.value;\n          }\n        } else if (encodedValue[Symbol.asyncIterator]) {\n          for await (let asyncValue of encodedValue) {\n            restartEncoding();\n            if (asyncValue) yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));else yield encoder.encode(asyncValue);\n          }\n        } else {\n          yield encodedValue;\n        }\n      }\n    }\n  }\n  useBuffer(buffer) {\n    // this means we are finished using our own buffer and we can write over it safely\n    target = buffer;\n    targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);\n    position = 0;\n  }\n  clearSharedData() {\n    if (this.structures) this.structures = [];\n    if (this.sharedValues) this.sharedValues = undefined;\n  }\n  updateSharedData() {\n    let lastVersion = this.sharedVersion || 0;\n    this.sharedVersion = lastVersion + 1;\n    let structuresCopy = this.structures.slice(0);\n    let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);\n    let saveResults = this.saveShared(sharedData, existingShared => (existingShared && existingShared.version || 0) == lastVersion);\n    if (saveResults === false) {\n      // get updated structures and try again if the update failed\n      sharedData = this.getShared() || {};\n      this.structures = sharedData.structures || [];\n      this.sharedValues = sharedData.packedValues;\n      this.sharedVersion = sharedData.version;\n      this.structures.nextId = this.structures.length;\n    } else {\n      // restore structures\n      structuresCopy.forEach((structure, i) => this.structures[i] = structure);\n    }\n    // saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n    return saveResults;\n  }\n}\nfunction writeEntityLength(length, majorValue) {\n  if (length < 0x18) target[position++] = majorValue | length;else if (length < 0x100) {\n    target[position++] = majorValue | 0x18;\n    target[position++] = length;\n  } else if (length < 0x10000) {\n    target[position++] = majorValue | 0x19;\n    target[position++] = length >> 8;\n    target[position++] = length & 0xff;\n  } else {\n    target[position++] = majorValue | 0x1a;\n    targetView.setUint32(position, length);\n    position += 4;\n  }\n}\nclass SharedData {\n  constructor(structures, values, version) {\n    this.structures = structures;\n    this.packedValues = values;\n    this.version = version;\n  }\n}\nfunction writeArrayHeader(length) {\n  if (length < 0x18) target[position++] = 0x80 | length;else if (length < 0x100) {\n    target[position++] = 0x98;\n    target[position++] = length;\n  } else if (length < 0x10000) {\n    target[position++] = 0x99;\n    target[position++] = length >> 8;\n    target[position++] = length & 0xff;\n  } else {\n    target[position++] = 0x9a;\n    targetView.setUint32(position, length);\n    position += 4;\n  }\n}\nconst BlobConstructor = typeof Blob === 'undefined' ? function () {} : Blob;\nfunction isBlob(object) {\n  if (object instanceof BlobConstructor) return true;\n  let tag = object[Symbol.toStringTag];\n  return tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n  switch (typeof value) {\n    case 'string':\n      if (value.length > 3) {\n        if (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues) return;\n        let packedStatus = packedValues.get(value);\n        if (packedStatus) {\n          if (++packedStatus.count == 2) {\n            packedValues.values.push(value);\n          }\n        } else {\n          packedValues.set(value, {\n            count: 1\n          });\n          if (packedValues.samplingPackedValues) {\n            let status = packedValues.samplingPackedValues.get(value);\n            if (status) status.count++;else packedValues.samplingPackedValues.set(value, {\n              count: 1\n            });\n          }\n        }\n      }\n      break;\n    case 'object':\n      if (value) {\n        if (value instanceof Array) {\n          for (let i = 0, l = value.length; i < l; i++) {\n            findRepetitiveStrings(value[i], packedValues);\n          }\n        } else {\n          let includeKeys = !packedValues.encoder.useRecords;\n          for (var key in value) {\n            if (value.hasOwnProperty(key)) {\n              if (includeKeys) findRepetitiveStrings(key, packedValues);\n              findRepetitiveStrings(value[key], packedValues);\n            }\n          }\n        }\n      }\n      break;\n    case 'function':\n      console.log(value);\n  }\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;\nextensionClasses = [Date, Set, Error, RegExp, Tag, ArrayBuffer, Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == 'undefined' ? function () {} : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == 'undefined' ? function () {} : BigInt64Array, Float32Array, Float64Array, SharedData];\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{\n  // Date\n  tag: 1,\n  encode(date, encode) {\n    let seconds = date.getTime() / 1000;\n    if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n      // Timestamp 32\n      target[position++] = 0x1a;\n      targetView.setUint32(position, seconds);\n      position += 4;\n    } else {\n      // Timestamp float64\n      target[position++] = 0xfb;\n      targetView.setFloat64(position, seconds);\n      position += 8;\n    }\n  }\n}, {\n  // Set\n  tag: 258,\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  encode(set, encode) {\n    let array = Array.from(set);\n    encode(array);\n  }\n}, {\n  // Error\n  tag: 27,\n  // http://cbor.schmorp.de/generic-object\n  encode(error, encode) {\n    encode([error.name, error.message]);\n  }\n}, {\n  // RegExp\n  tag: 27,\n  // http://cbor.schmorp.de/generic-object\n  encode(regex, encode) {\n    encode(['RegExp', regex.source, regex.flags]);\n  }\n}, {\n  // Tag\n  getTag(tag) {\n    return tag.tag;\n  },\n  encode(tag, encode) {\n    encode(tag.value);\n  }\n}, {\n  // ArrayBuffer\n  encode(arrayBuffer, encode, makeRoom) {\n    writeBuffer(arrayBuffer, makeRoom);\n  }\n}, {\n  // Uint8Array\n  getTag(typedArray) {\n    if (typedArray.constructor === Uint8Array) {\n      if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false) return 64;\n    } // else no tag\n  },\n\n  encode(typedArray, encode, makeRoom) {\n    writeBuffer(typedArray, makeRoom);\n  }\n}, typedArrayEncoder(68, 1), typedArrayEncoder(69, 2), typedArrayEncoder(70, 4), typedArrayEncoder(71, 8), typedArrayEncoder(72, 1), typedArrayEncoder(77, 2), typedArrayEncoder(78, 4), typedArrayEncoder(79, 8), typedArrayEncoder(85, 4), typedArrayEncoder(86, 8), {\n  encode(sharedData, encode) {\n    // write SharedData\n    let packedValues = sharedData.packedValues || [];\n    let sharedStructures = sharedData.structures || [];\n    if (packedValues.values.length > 0) {\n      target[position++] = 0xd8; // one-byte tag\n      target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n      writeArrayHeader(4);\n      let valuesArray = packedValues.values;\n      encode(valuesArray);\n      writeArrayHeader(0); // prefixes\n      writeArrayHeader(0); // suffixes\n      packedObjectMap = Object.create(sharedPackedObjectMap || null);\n      for (let i = 0, l = valuesArray.length; i < l; i++) {\n        packedObjectMap[valuesArray[i]] = i;\n      }\n    }\n    if (sharedStructures) {\n      targetView.setUint32(position, 0xd9dffe00);\n      position += 3;\n      let definitions = sharedStructures.slice(0);\n      definitions.unshift(0xe000);\n      definitions.push(new Tag(sharedData.version, 0x53687264));\n      encode(definitions);\n    } else encode(new Tag(sharedData.version, 0x53687264));\n  }\n}];\nfunction typedArrayEncoder(tag, size) {\n  if (!isLittleEndianMachine && size > 1) tag -= 4; // the big endian equivalents are 4 less\n  return {\n    tag: tag,\n    encode: function writeExtBuffer(typedArray, encode) {\n      let length = typedArray.byteLength;\n      let offset = typedArray.byteOffset || 0;\n      let buffer = typedArray.buffer || typedArray;\n      encode(hasNodeBuffer ? Buffer.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));\n    }\n  };\n}\nfunction writeBuffer(buffer, makeRoom) {\n  let length = buffer.byteLength;\n  if (length < 0x18) {\n    target[position++] = 0x40 + length;\n  } else if (length < 0x100) {\n    target[position++] = 0x58;\n    target[position++] = length;\n  } else if (length < 0x10000) {\n    target[position++] = 0x59;\n    target[position++] = length >> 8;\n    target[position++] = length & 0xff;\n  } else {\n    target[position++] = 0x5a;\n    targetView.setUint32(position, length);\n    position += 4;\n  }\n  if (position + length >= target.length) {\n    makeRoom(position + length);\n  }\n  // if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n  // must wrap it to set it.\n  target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position);\n  position += length;\n}\nfunction insertIds(serialized, idsToInsert) {\n  // insert the ids that need to be referenced for structured clones\n  let nextId;\n  let distanceToMove = idsToInsert.length * 2;\n  let lastEnd = serialized.length - distanceToMove;\n  idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n  for (let id = 0; id < idsToInsert.length; id++) {\n    let referee = idsToInsert[id];\n    referee.id = id;\n    for (let position of referee.references) {\n      serialized[position++] = id >> 8;\n      serialized[position] = id & 0xff;\n    }\n  }\n  while (nextId = idsToInsert.pop()) {\n    let offset = nextId.offset;\n    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n    distanceToMove -= 2;\n    let position = offset + distanceToMove;\n    serialized[position++] = 0xd8;\n    serialized[position++] = 28; // http://cbor.schmorp.de/value-sharing\n    lastEnd = offset;\n  }\n  return serialized;\n}\nfunction writeBundles(start, encode) {\n  targetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1); // the offset to bundle\n  let writeStrings = bundledStrings;\n  bundledStrings = null;\n  encode(writeStrings[0]);\n  encode(writeStrings[1]);\n}\nexport function addExtension(extension) {\n  if (extension.Class) {\n    if (!extension.encode) throw new Error('Extension has no encode function');\n    extensionClasses.unshift(extension.Class);\n    extensions.unshift(extension);\n  }\n  decodeAddExtension(extension);\n}\nlet defaultEncoder = new Encoder({\n  useRecords: false\n});\nexport const encode = defaultEncoder.encode;\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable;\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;\nexport { FLOAT32_OPTIONS } from './decode.js';\nimport { FLOAT32_OPTIONS } from './decode.js';\nexport const {\n  NEVER,\n  ALWAYS,\n  DECIMAL_ROUND,\n  DECIMAL_FIT\n} = FLOAT32_OPTIONS;\nexport const REUSE_BUFFER_MODE = 512;\nexport const RESET_BUFFER_MODE = 1024;\nexport const THROW_ON_ITERABLE = 2048;","map":{"version":3,"names":["Decoder","mult10","Tag","typedArrays","addExtension","decodeAddExtension","textEncoder","TextEncoder","error","extensions","extensionClasses","Buffer","globalThis","hasNodeBuffer","ByteArrayAllocate","allocUnsafeSlow","Uint8Array","ByteArray","MAX_STRUCTURES","MAX_BUFFER_SIZE","serializationId","throwOnIterable","target","targetView","position","safeEnd","bundledStrings","MAX_BUNDLE_SIZE","hasNonLatin","RECORD_SYMBOL","Symbol","Encoder","constructor","options","offset","typeBuffer","start","sharedStructures","hasSharedUpdate","structures","referenceMap","encodeUtf8","prototype","utf8Write","string","maxBytes","encodeInto","subarray","written","encoder","hasSharedStructures","saveStructures","maxSharedStructures","Error","isSequential","sequential","saveShared","samplingPackedValues","packedObjectMap","sharedValues","sharedPackedObjectMap","Object","create","i","l","length","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","mapEncode","value","encodeOptions","_keyMap","_mapped","name","map","r","encodeKeys","encode","DataView","buffer","REUSE_BUFFER_MODE","useSelfDescribedHeader","setUint32","structuredClone","Map","bundleStrings","size","Infinity","uninitialized","sharedData","getShared","sharedVersion","version","packedValues","sharedStructuresLength","transitions","keys","nextTransition","transition","j","undefined","key","nextId","pack","values","maxValues","maxPrivatePackedValues","objectMap","findRepetitiveStrings","writeArrayHeader","valuesArray","THROW_ON_ITERABLE","writeBundles","idsToInsert","makeRoom","serialized","insertIds","end","slice","returnBuffer","updateSharedData","RESET_BUFFER_MODE","findCommonStringsToPack","threshold","status","count","push","type","packedPosition","get","set","strLength","extStart","twoByte","test","headerSize","c1","c2","strPosition","charCodeAt","copyWithin","alwaysUseFloat","setUint16","useFloat32","setFloat32","xShifted","setFloat64","referee","references","writeObject","Array","mapsAsObjects","useTag259ForMaps","keyMap","entryValue","encodeKey","extensionClass","extension","tag","getTag","call","iterator","iteratorNotHandled","entry","asyncIterator","isBlob","useToJSON","toJSON","json","hasOwnProperty","BigInt","setBigUint64","largeBigIntToFloat","Number","RangeError","useRecords","variableMapSize","object","vals","safePrototype","objectOffset","newTransitions","parentRecordId","k","recordId","__keys__","shift","newSize","Math","min","round","max","newBuffer","copy","chunkThreshold","continuedChunkThreshold","encodeAsIterable","startEncoding","encodeObjectAsIterable","encodeAsAsyncIterable","encodeObjectAsAsyncIterable","iterateProperties","finalIterable","writeEntityLength","tryEncode","element","restartEncoding","restart","encodeIterable","encodedValue","reader","stream","getReader","next","read","done","asyncValue","async","useBuffer","byteOffset","byteLength","clearSharedData","lastVersion","structuresCopy","SharedData","saveResults","existingShared","forEach","structure","majorValue","BlobConstructor","Blob","toStringTag","packedStatus","includeKeys","console","log","isLittleEndianMachine","Uint16Array","Date","Set","RegExp","ArrayBuffer","Uint8ClampedArray","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","Float32Array","Float64Array","date","seconds","getTime","useTimestamp32","getMilliseconds","array","from","message","regex","source","flags","arrayBuffer","writeBuffer","typedArray","tagUint8Array","typedArrayEncoder","definitions","unshift","writeExtBuffer","distanceToMove","lastEnd","sort","a","b","id","pop","writeStrings","Class","defaultEncoder","FLOAT32_OPTIONS","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT"],"sources":["C:/Users//Desktop/WeLearn/Frontend_WeLearn/node_modules/cbor-x/encode.js"],"sourcesContent":["import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (safePrototype === null) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, null); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}