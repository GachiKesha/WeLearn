{"ast":null,"code":"let decoder;\ntry {\n  decoder = new TextDecoder();\n} catch (error) {}\nlet src;\nlet srcEnd;\nlet position = 0;\nlet alreadySet;\nconst EMPTY_ARRAY = [];\nconst LEGACY_RECORD_INLINE_ID = 105;\nconst RECORD_DEFINITIONS_ID = 0xdffe;\nconst RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9;\nconst PACKED_TABLE_TAG_ID = 51;\nconst PACKED_REFERENCE_TAG_ID = 6;\nconst STOP_CODE = {};\nlet strings = EMPTY_ARRAY;\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nlet srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nlet currentExtensions = [];\nlet currentExtensionRanges = [];\nlet packedValues;\nlet dataView;\nlet restoreMapsAsObject;\nlet defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true\n};\nlet sequentialMode = false;\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction; // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n  new Function('');\n} catch (error) {\n  // if eval variants are not supported, do not create inline object readers ever\n  inlineObjectReadThreshold = Infinity;\n}\nexport class Decoder {\n  constructor(options) {\n    if (options) {\n      if ((options.keyMap || options._keyMap) && !options.useRecords) {\n        options.useRecords = false;\n        options.mapsAsObjects = true;\n      }\n      if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;\n      if (options.getStructures) options.getShared = options.getStructures;\n      if (options.getShared && !options.structures) (options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures\n      if (options.keyMap) {\n        this.mapKey = new Map();\n        for (let [k, v] of Object.entries(options.keyMap)) this.mapKey.set(v, k);\n      }\n    }\n    Object.assign(this, options);\n  }\n  /*\n  decodeKey(key) {\n  \treturn this.keyMap\n  \t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n  \t\t: key\n  }\n  */\n  decodeKey(key) {\n    return this.keyMap ? this.mapKey.get(key) || key : key;\n  }\n  encodeKey(key) {\n    return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;\n  }\n  encodeKeys(rec) {\n    if (!this._keyMap) return rec;\n    let map = new Map();\n    for (let [k, v] of Object.entries(rec)) map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);\n    return map;\n  }\n  decodeKeys(map) {\n    if (!this._keyMap || map.constructor.name != 'Map') return map;\n    if (!this._mapKey) {\n      this._mapKey = new Map();\n      for (let [k, v] of Object.entries(this._keyMap)) this._mapKey.set(v, k);\n    }\n    let res = {};\n    //map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n    map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);\n    return res;\n  }\n  mapDecode(source, end) {\n    let res = this.decode(source);\n    if (this._keyMap) {\n      //Experiemntal support for Optimised KeyMap  decoding \n      switch (res.constructor.name) {\n        case 'Array':\n          return res.map(r => this.decodeKeys(r));\n        //case 'Map': return this.decodeKeys(res)\n      }\n    }\n\n    return res;\n  }\n  decode(source, end) {\n    if (src) {\n      // re-entrant execution, save the state and restore it after we do this decode\n      return saveState(() => {\n        clearSource();\n        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);\n      });\n    }\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) throw error;\n      throw new Error('Source must be a Uint8Array or Buffer but was a ' + (source && typeof source == 'object' ? source.constructor.name : typeof source));\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n      if (this.structures) {\n        currentStructures = this.structures;\n        return checkedRead();\n      } else if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) currentStructures = [];\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n  decodeMultiple(source, forEach) {\n    let values,\n      lastPosition = 0;\n    try {\n      let size = source.length;\n      sequentialMode = true;\n      let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);\n      if (forEach) {\n        if (forEach(value) === false) {\n          return;\n        }\n        while (position < size) {\n          lastPosition = position;\n          if (forEach(checkedRead()) === false) {\n            return;\n          }\n        }\n      } else {\n        values = [value];\n        while (position < size) {\n          lastPosition = position;\n          values.push(checkedRead());\n        }\n        return values;\n      }\n    } catch (error) {\n      error.lastPosition = lastPosition;\n      error.values = values;\n      throw error;\n    } finally {\n      sequentialMode = false;\n      clearSource();\n    }\n  }\n}\nexport function getPosition() {\n  return position;\n}\nexport function checkedRead() {\n  try {\n    let result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        let error = new Error('Unexpected bundle position');\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n    if (position == srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) referenceMap = null;\n    } else if (position > srcEnd) {\n      // over read\n      let error = new Error('Unexpected end of CBOR data');\n      error.incomplete = true;\n      throw error;\n    } else if (!sequentialMode) {\n      throw new Error('Data read, but end of buffer not reached');\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\nexport function read() {\n  let token = src[position++];\n  let majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        if (majorType == 7) {\n          return getFloat16();\n        }\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        if (majorType == 7) {\n          let value = dataView.getFloat32(position);\n          if (currentDecoder.useFloat32 > 2) {\n            // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n            let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];\n            position += 4;\n            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n          }\n          position += 4;\n          return value;\n        }\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n      case 0x1b:\n        if (majorType == 7) {\n          let value = dataView.getFloat64(position);\n          position += 8;\n          return value;\n        }\n        if (majorType > 1) {\n          if (dataView.getUint32(position) > 0) throw new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295');\n          token = dataView.getUint32(position + 4);\n        } else if (currentDecoder.int64AsNumber) {\n          token = dataView.getUint32(position) * 0x100000000;\n          token += dataView.getUint32(position + 4);\n        } else token = dataView.getBigUint64(position);\n        position += 8;\n        break;\n      case 0x1f:\n        // indefinite length\n        switch (majorType) {\n          case 2: // byte string\n          case 3:\n            // text string\n            throw new Error('Indefinite length not supported for byte or text strings');\n          case 4:\n            // array\n            let array = [];\n            let value,\n              i = 0;\n            while ((value = read()) != STOP_CODE) {\n              array[i++] = value;\n            }\n            return majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array);\n          case 5:\n            // map\n            let key;\n            if (currentDecoder.mapsAsObjects) {\n              let object = {};\n              if (currentDecoder.keyMap) while ((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read();else while ((key = read()) != STOP_CODE) object[safeKey(key)] = read();\n              return object;\n            } else {\n              if (restoreMapsAsObject) {\n                currentDecoder.mapsAsObjects = true;\n                restoreMapsAsObject = false;\n              }\n              let map = new Map();\n              if (currentDecoder.keyMap) while ((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read());else while ((key = read()) != STOP_CODE) map.set(key, read());\n              return map;\n            }\n          case 7:\n            return STOP_CODE;\n          default:\n            throw new Error('Invalid major type for indefinite length ' + majorType);\n        }\n      default:\n        throw new Error('Unknown token ' + token);\n    }\n  }\n  switch (majorType) {\n    case 0:\n      // positive int\n      return token;\n    case 1:\n      // negative int\n      return ~token;\n    case 2:\n      // buffer\n      return readBin(token);\n    case 3:\n      // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n      }\n      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string != null) return string;\n      }\n      return readFixedString(token);\n    case 4:\n      // array\n      let array = new Array(token);\n      //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n      //else \n      for (let i = 0; i < token; i++) array[i] = read();\n      return array;\n    case 5:\n      // map\n      if (currentDecoder.mapsAsObjects) {\n        let object = {};\n        if (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read();else for (let i = 0; i < token; i++) object[safeKey(read())] = read();\n        return object;\n      } else {\n        if (restoreMapsAsObject) {\n          currentDecoder.mapsAsObjects = true;\n          restoreMapsAsObject = false;\n        }\n        let map = new Map();\n        if (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()), read());else for (let i = 0; i < token; i++) map.set(read(), read());\n        return map;\n      }\n    case 6:\n      // extension\n      if (token >= BUNDLED_STRINGS_ID) {\n        let structure = currentStructures[token & 0x1fff]; // check record structures first\n        // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n        if (structure) {\n          if (!structure.read) structure.read = createStructureReader(structure);\n          return structure.read();\n        }\n        if (token < 0x10000) {\n          if (token == RECORD_INLINE_ID) {\n            // we do a special check for this so that we can keep the\n            // currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n            let length = readJustLength();\n            let id = read();\n            let structure = read();\n            recordDefinition(id, structure);\n            let object = {};\n            if (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n              let key = currentDecoder.decodeKey(structure[i - 2]);\n              object[safeKey(key)] = read();\n            } else for (let i = 2; i < length; i++) {\n              let key = structure[i - 2];\n              object[safeKey(key)] = read();\n            }\n            return object;\n          } else if (token == RECORD_DEFINITIONS_ID) {\n            let length = readJustLength();\n            let id = read();\n            for (let i = 2; i < length; i++) {\n              recordDefinition(id++, read());\n            }\n            return read();\n          } else if (token == BUNDLED_STRINGS_ID) {\n            return readBundleExt();\n          }\n          if (currentDecoder.getShared) {\n            loadShared();\n            structure = currentStructures[token & 0x1fff];\n            if (structure) {\n              if (!structure.read) structure.read = createStructureReader(structure);\n              return structure.read();\n            }\n          }\n        }\n      }\n      let extension = currentExtensions[token];\n      if (extension) {\n        if (extension.handlesRead) return extension(read);else return extension(read());\n      } else {\n        let input = read();\n        for (let i = 0; i < currentExtensionRanges.length; i++) {\n          let value = currentExtensionRanges[i](token, input);\n          if (value !== undefined) return value;\n        }\n        return new Tag(input, token);\n      }\n    case 7:\n      // fixed value\n      switch (token) {\n        case 0x14:\n          return false;\n        case 0x15:\n          return true;\n        case 0x16:\n          return null;\n        case 0x17:\n          return;\n        // undefined\n        case 0x1f:\n        default:\n          let packedValue = (packedValues || getPackedValues())[token];\n          if (packedValue !== undefined) return packedValue;\n          throw new Error('Unknown token ' + token);\n      }\n    default:\n      // negative int\n      if (isNaN(token)) {\n        let error = new Error('Unexpected end of CBOR data');\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error('Unknown CBOR token ' + token);\n  }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure) {\n  function readObject() {\n    // get the array size from the header\n    let length = src[position++];\n    //let majorType = token >> 5\n    length = length & 0x1f;\n    if (length > 0x17) {\n      switch (length) {\n        case 0x18:\n          length = src[position++];\n          break;\n        case 0x19:\n          length = dataView.getUint16(position);\n          position += 2;\n          break;\n        case 0x1a:\n          length = dataView.getUint32(position);\n          position += 4;\n          break;\n        default:\n          throw new Error('Expected array header, but got ' + src[position - 1]);\n      }\n    }\n    // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n    let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function\n    while (compiledReader) {\n      // we have a fast compiled object literal reader\n      if (compiledReader.propertyCount === length) return compiledReader(read); // with the right length, so we use it\n      compiledReader = compiledReader.next; // see if there is another reader with the right length\n    }\n\n    if (this.slowReads++ >= inlineObjectReadThreshold) {\n      // create a fast compiled reader\n      let array = this.length == length ? this : this.slice(0, length);\n      compiledReader = currentDecoder.keyMap ? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : '[' + JSON.stringify(k) + ']:r()').join(',') + '}') : new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : '[' + JSON.stringify(key) + ']:r()').join(',') + '}');\n      if (this.compiledReader) compiledReader.next = this.compiledReader; // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n      compiledReader.propertyCount = length;\n      this.compiledReader = compiledReader;\n      return compiledReader(read);\n    }\n    let object = {};\n    if (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read();else for (let i = 0; i < length; i++) {\n      object[safeKey(this[i])] = read();\n    }\n    return object;\n  }\n  structure.slowReads = 0;\n  return readObject;\n}\nfunction safeKey(key) {\n  return key === '__proto__' ? '__proto_' : key;\n}\nlet readFixedString = readStringJS;\nlet readString8 = readStringJS;\nlet readString16 = readStringJS;\nlet readString32 = readStringJS;\nexport let isNativeAccelerationEnabled = false;\nexport function setExtractor(extractStrings) {\n  isNativeAccelerationEnabled = true;\n  readFixedString = readString(1);\n  readString8 = readString(2);\n  readString16 = readString(3);\n  readString32 = readString(5);\n  function readString(headerLength) {\n    return function readString(length) {\n      let string = strings[stringPosition++];\n      if (string == null) {\n        if (bundledStrings) return readStringJS(length);\n        let extraction = extractStrings(position, srcEnd, length, src);\n        if (typeof extraction == 'string') {\n          string = extraction;\n          strings = EMPTY_ARRAY;\n        } else {\n          strings = extraction;\n          stringPosition = 1;\n          srcStringEnd = 1; // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n          string = strings[0];\n          if (string === undefined) throw new Error('Unexpected end of buffer');\n        }\n      }\n      let srcStringLength = string.length;\n      if (srcStringLength <= length) {\n        position += length;\n        return string;\n      }\n      srcString = string;\n      srcStringStart = position;\n      srcStringEnd = position + srcStringLength;\n      position += length;\n      return string.slice(0, length); // we know we just want the beginning\n    };\n  }\n}\n\nfunction readStringJS(length) {\n  let result;\n  if (length < 16) {\n    if (result = shortStringInJS(length)) return result;\n  }\n  if (length > 64 && decoder) return decoder.decode(src.subarray(position, position += length));\n  const end = position + length;\n  const units = [];\n  result = '';\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      const byte4 = src[position++] & 0x3f;\n      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n  return result;\n}\nlet fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  let start = position;\n  let bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) return '';else {\n        let a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n      }\n    } else {\n      let a = src[position++];\n      let b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) return fromCharCode(a, b);\n      let c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n    }\n  } else {\n    let a = src[position++];\n    let b = src[position++];\n    let c = src[position++];\n    let d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) return fromCharCode(a, b, c, d);else {\n        let e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n      }\n    } else if (length < 8) {\n      let e = src[position++];\n      let f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) return fromCharCode(a, b, c, d, e, f);\n      let g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    } else {\n      let e = src[position++];\n      let f = src[position++];\n      let g = src[position++];\n      let h = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h);else {\n          let i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n        }\n      } else if (length < 12) {\n        let i = src[position++];\n        let j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        let k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      } else {\n        let i = src[position++];\n        let j = src[position++];\n        let k = src[position++];\n        let l = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);else {\n            let m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n          }\n        } else {\n          let m = src[position++];\n          let n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          let o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n        }\n      }\n    }\n  }\n}\nfunction readBin(length) {\n  return currentDecoder.copyBuffers ?\n  // specifically use the copying slice (not the node one)\n  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nfunction readExt(length) {\n  let type = src[position++];\n  if (currentExtensions[type]) {\n    return currentExtensions[type](src.subarray(position, position += length));\n  } else throw new Error('Unknown extension type ' + type);\n}\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction getFloat16() {\n  let byte0 = src[position++];\n  let byte1 = src[position++];\n  let exponent = (byte0 & 0x7f) >> 2;\n  if (exponent === 0x1f) {\n    // specials\n    if (byte1 || byte0 & 3) return NaN;\n    return byte0 & 0x80 ? -Infinity : Infinity;\n  }\n  if (exponent === 0) {\n    // sub-normals\n    // significand with 10 fractional bits and divided by 2^14\n    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);\n    return byte0 & 0x80 ? -abs : abs;\n  }\n  u8Array[3] = byte0 & 0x80 |\n  // sign bit\n  (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed\n  u8Array[2] = (byte0 & 7) << 5 |\n  // last exponent bit and first two mantissa bits\n  byte1 >> 3; // next 5 bits of mantissa\n  u8Array[1] = byte1 << 5; // last three bits of mantissa\n  u8Array[0] = 0;\n  return f32Array[0];\n}\nlet keyCache = new Array(4096);\nfunction readKey() {\n  let length = src[position++];\n  if (length >= 0x60 && length < 0x78) {\n    // fixstr, potentially use key cache\n    length = length - 0x60;\n    if (srcStringEnd >= position)\n      // if it has been extracted, must use it (and faster anyway)\n      return srcString.slice(position - srcStringStart, (position += length) - srcStringStart);else if (!(srcStringEnd == 0 && srcEnd < 180)) return readFixedString(length);\n  } else {\n    // not cacheable, go back and do a standard read\n    position--;\n    return read();\n  }\n  let key = (length << 5 ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff;\n  let entry = keyCache[key];\n  let checkPosition = position;\n  let end = position + length - 3;\n  let chunk;\n  let i = 0;\n  if (entry && entry.bytes == length) {\n    while (checkPosition < end) {\n      chunk = dataView.getUint32(checkPosition);\n      if (chunk != entry[i++]) {\n        checkPosition = 0x70000000;\n        break;\n      }\n      checkPosition += 4;\n    }\n    end += 3;\n    while (checkPosition < end) {\n      chunk = src[checkPosition++];\n      if (chunk != entry[i++]) {\n        checkPosition = 0x70000000;\n        break;\n      }\n    }\n    if (checkPosition === end) {\n      position = checkPosition;\n      return entry.string;\n    }\n    end -= 3;\n    checkPosition = position;\n  }\n  entry = [];\n  keyCache[key] = entry;\n  entry.bytes = length;\n  while (checkPosition < end) {\n    chunk = dataView.getUint32(checkPosition);\n    entry.push(chunk);\n    checkPosition += 4;\n  }\n  end += 3;\n  while (checkPosition < end) {\n    chunk = src[checkPosition++];\n    entry.push(chunk);\n  }\n  // for small blocks, avoiding the overhead of the extract call is helpful\n  let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n  if (string != null) return entry.string = string;\n  return entry.string = readFixedString(length);\n}\nexport class Tag {\n  constructor(value, tag) {\n    this.value = value;\n    this.tag = tag;\n  }\n}\ncurrentExtensions[0] = dateString => {\n  // string date extension\n  return new Date(dateString);\n};\ncurrentExtensions[1] = epochSec => {\n  // numeric date extension\n  return new Date(Math.round(epochSec * 1000));\n};\ncurrentExtensions[2] = buffer => {\n  // bigint extension\n  let value = BigInt(0);\n  for (let i = 0, l = buffer.byteLength; i < l; i++) {\n    value = BigInt(buffer[i]) + value << BigInt(8);\n  }\n  return value;\n};\ncurrentExtensions[3] = buffer => {\n  // negative bigint extension\n  return BigInt(-1) - currentExtensions[2](buffer);\n};\ncurrentExtensions[4] = fraction => {\n  // best to reparse to maintain accuracy\n  return +(fraction[1] + 'e' + fraction[0]);\n};\ncurrentExtensions[5] = fraction => {\n  // probably not sufficiently accurate\n  return fraction[1] * Math.exp(fraction[0] * Math.log(2));\n};\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n  id = id - 0xe000;\n  let existingStructure = currentStructures[id];\n  if (existingStructure && existingStructure.isShared) {\n    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n  }\n  currentStructures[id] = structure;\n  structure.read = createStructureReader(structure);\n};\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = data => {\n  let length = data.length;\n  let structure = data[1];\n  recordDefinition(data[0], structure);\n  let object = {};\n  for (let i = 2; i < length; i++) {\n    let key = structure[i - 2];\n    object[safeKey(key)] = data[i];\n  }\n  return object;\n};\ncurrentExtensions[14] = value => {\n  if (bundledStrings) return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);\n  return new Tag(value, 14);\n};\ncurrentExtensions[15] = value => {\n  if (bundledStrings) return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);\n  return new Tag(value, 15);\n};\nlet glbl = {\n  Error,\n  RegExp\n};\ncurrentExtensions[27] = data => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = read => {\n  if (src[position++] != 0x84) throw new Error('Packed values structure must be followed by a 4 element array');\n  let newPackedValues = read(); // packed values\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;\n  packedValues.prefixes = read();\n  packedValues.suffixes = read();\n  return read(); // read the rump\n};\n\npackedTable.handlesRead = true;\ncurrentExtensions[51] = packedTable;\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = data => {\n  // packed reference\n  if (!packedValues) {\n    if (currentDecoder.getShared) loadShared();else return new Tag(data, PACKED_REFERENCE_TAG_ID);\n  }\n  if (typeof data == 'number') return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];\n  throw new Error('No support for non-integer packed references yet');\n};\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = read => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  let id = referenceMap.id++;\n  let token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 == 4) target = [];else target = {};\n  let refEntry = {\n    target\n  }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  let targetProperties = read(); // read the next value as the target object to id\n  if (refEntry.used)\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\ncurrentExtensions[28].handlesRead = true;\ncurrentExtensions[29] = id => {\n  // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n  let refEntry = referenceMap.get(id);\n  refEntry.used = true;\n  return refEntry.target;\n};\ncurrentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = read => {\n  // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n  // for decoding as a standard Map\n  if (currentDecoder.mapsAsObjects) {\n    currentDecoder.mapsAsObjects = false;\n    restoreMapsAsObject = true;\n  }\n  return read();\n}).handlesRead = true;\nfunction combine(a, b) {\n  if (typeof a === 'string') return a + b;\n  if (a instanceof Array) return a.concat(b);\n  return Object.assign({}, a, b);\n}\nfunction getPackedValues() {\n  if (!packedValues) {\n    if (currentDecoder.getShared) loadShared();else throw new Error('No packed values available');\n  }\n  return packedValues;\n}\nconst SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n  if (tag >= 225 && tag <= 255) return combine(getPackedValues().prefixes[tag - 224], input);\n  if (tag >= 28704 && tag <= 32767) return combine(getPackedValues().prefixes[tag - 28672], input);\n  if (tag >= 1879052288 && tag <= 2147483647) return combine(getPackedValues().prefixes[tag - 1879048192], input);\n  if (tag >= 216 && tag <= 223) return combine(input, getPackedValues().suffixes[tag - 216]);\n  if (tag >= 27647 && tag <= 28671) return combine(input, getPackedValues().suffixes[tag - 27639]);\n  if (tag >= 1811940352 && tag <= 1879048191) return combine(input, getPackedValues().suffixes[tag - 1811939328]);\n  if (tag == SHARED_DATA_TAG_ID) {\n    // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n    return {\n      packedValues: packedValues,\n      structures: currentStructures.slice(0),\n      version: input\n    };\n  }\n  if (tag == 55799)\n    // self-descriptive CBOR tag, just return input value\n    return input;\n});\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, typeof BigUint64Array == 'undefined' ? {\n  name: 'BigUint64Array'\n} : BigUint64Array, Int8Array, Int16Array, Int32Array, typeof BigInt64Array == 'undefined' ? {\n  name: 'BigInt64Array'\n} : BigInt64Array, Float32Array, Float64Array];\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];\nfor (let i = 0; i < typedArrays.length; i++) {\n  registerTypedArray(typedArrays[i], typedArrayTags[i]);\n}\nfunction registerTypedArray(TypedArray, tag) {\n  let dvMethod = 'get' + TypedArray.name.slice(0, -5);\n  let bytesPerElement;\n  if (typeof TypedArray === 'function') bytesPerElement = TypedArray.BYTES_PER_ELEMENT;else TypedArray = null;\n  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n    if (!littleEndian && bytesPerElement == 1) continue;\n    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;\n    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? buffer => {\n      if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);\n      // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);\n    } : buffer => {\n      if (!TypedArray) throw new Error('Could not find typed array for code ' + tag);\n      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      let elements = buffer.length >> sizeShift;\n      let ta = new TypedArray(elements);\n      let method = dv[dvMethod];\n      for (let i = 0; i < elements; i++) {\n        ta[i] = method.call(dv, i << sizeShift, littleEndian);\n      }\n      return ta;\n    };\n  }\n}\nfunction readBundleExt() {\n  let length = readJustLength();\n  let bundlePosition = position + read();\n  for (let i = 2; i < length; i++) {\n    // skip past bundles that were already read\n    let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards\n    position += bundleLength;\n  }\n  let dataPosition = position;\n  position = bundlePosition;\n  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];\n  bundledStrings.position0 = 0;\n  bundledStrings.position1 = 0;\n  bundledStrings.postBundlePosition = position;\n  position = dataPosition;\n  return read();\n}\nfunction readJustLength() {\n  let token = src[position++] & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n    }\n  }\n  return token;\n}\nfunction loadShared() {\n  if (currentDecoder.getShared) {\n    let sharedData = saveState(() => {\n      // save the state in case getShared modifies our buffer\n      src = null;\n      return currentDecoder.getShared();\n    }) || {};\n    let updatedStructures = sharedData.structures || [];\n    currentDecoder.sharedVersion = sharedData.version;\n    packedValues = currentDecoder.sharedValues = sharedData.packedValues;\n    if (currentStructures === true) currentDecoder.structures = currentStructures = updatedStructures;else currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));\n  }\n}\nfunction saveState(callback) {\n  let savedSrcEnd = srcEnd;\n  let savedPosition = position;\n  let savedStringPosition = stringPosition;\n  let savedSrcStringStart = srcStringStart;\n  let savedSrcStringEnd = srcStringEnd;\n  let savedSrcString = srcString;\n  let savedStrings = strings;\n  let savedReferenceMap = referenceMap;\n  let savedBundledStrings = bundledStrings;\n\n  // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n  let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n  let savedStructures = currentStructures;\n  let savedDecoder = currentDecoder;\n  let savedSequentialMode = sequentialMode;\n  let value = callback();\n  srcEnd = savedSrcEnd;\n  position = savedPosition;\n  stringPosition = savedStringPosition;\n  srcStringStart = savedSrcStringStart;\n  srcStringEnd = savedSrcStringEnd;\n  srcString = savedSrcString;\n  strings = savedStrings;\n  referenceMap = savedReferenceMap;\n  bundledStrings = savedBundledStrings;\n  src = savedSrc;\n  sequentialMode = savedSequentialMode;\n  currentStructures = savedStructures;\n  currentDecoder = savedDecoder;\n  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n  return value;\n}\nexport function clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\nexport function addExtension(extension) {\n  currentExtensions[extension.tag] = extension.decode;\n}\nexport const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103));\n}\nlet defaultDecoder = new Decoder({\n  useRecords: false\n});\nexport const decode = defaultDecoder.decode;\nexport const decodeMultiple = defaultDecoder.decodeMultiple;\nexport const FLOAT32_OPTIONS = {\n  NEVER: 0,\n  ALWAYS: 1,\n  DECIMAL_ROUND: 3,\n  DECIMAL_FIT: 4\n};\nexport function roundFloat32(float32Number) {\n  f32Array[0] = float32Number;\n  let multiplier = mult10[(u8Array[3] & 0x7f) << 1 | u8Array[2] >> 7];\n  return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n}","map":{"version":3,"names":["decoder","TextDecoder","error","src","srcEnd","position","alreadySet","EMPTY_ARRAY","LEGACY_RECORD_INLINE_ID","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","PACKED_TABLE_TAG_ID","PACKED_REFERENCE_TAG_ID","STOP_CODE","strings","stringPosition","currentDecoder","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","currentExtensions","currentExtensionRanges","packedValues","dataView","restoreMapsAsObject","defaultOptions","useRecords","mapsAsObjects","sequentialMode","inlineObjectReadThreshold","BlockedFunction","Function","Infinity","Decoder","constructor","options","keyMap","_keyMap","undefined","getStructures","getShared","structures","uninitialized","mapKey","Map","k","v","Object","entries","set","assign","decodeKey","key","get","encodeKey","hasOwnProperty","encodeKeys","rec","map","decodeKeys","name","_mapKey","res","forEach","safeKey","has","mapDecode","source","end","decode","r","saveState","clearSource","prototype","call","length","DataView","buffer","byteOffset","byteLength","Uint8Array","Error","sharedValues","pack","Array","maxPrivatePackedValues","concat","checkedRead","decodeMultiple","values","lastPosition","size","value","defaultDecoder","push","getPosition","result","read","postBundlePosition","incomplete","RangeError","message","startsWith","token","majorType","getFloat16","getUint16","getFloat32","useFloat32","multiplier","mult10","getUint32","getFloat64","int64AsNumber","getBigUint64","array","i","join","Buffer","object","readBin","slice","string","shortStringInJS","longStringInJS","readFixedString","structure","createStructureReader","readJustLength","id","recordDefinition","readBundleExt","loadShared","extension","handlesRead","input","Tag","packedValue","getPackedValues","isNaN","validName","readObject","compiledReader","propertyCount","next","slowReads","test","JSON","stringify","readStringJS","readString8","readString16","readString32","isNativeAccelerationEnabled","setExtractor","extractStrings","readString","headerLength","extraction","srcStringLength","subarray","units","byte1","byte2","byte3","byte4","unit","fromCharCode","apply","String","start","bytes","byte","a","b","c","d","e","f","g","h","j","l","m","n","o","copyBuffers","readExt","type","f32Array","Float32Array","u8Array","byte0","exponent","NaN","abs","keyCache","readKey","entry","checkPosition","chunk","tag","dateString","Date","epochSec","Math","round","BigInt","fraction","exp","log","existingStructure","isShared","restoreStructures","data","position0","position1","glbl","RegExp","packedTable","newPackedValues","prefixes","suffixes","target","refEntry","targetProperties","used","Set","combine","SHARED_DATA_TAG_ID","version","isLittleEndianMachine","Uint16Array","typedArrays","Uint8ClampedArray","Uint32Array","BigUint64Array","Int8Array","Int16Array","Int32Array","BigInt64Array","Float64Array","typedArrayTags","registerTypedArray","TypedArray","dvMethod","bytesPerElement","BYTES_PER_ELEMENT","littleEndian","sizeShift","dv","elements","ta","method","bundlePosition","bundleLength","dataPosition","sharedData","updatedStructures","sharedVersion","splice","callback","savedSrcEnd","savedPosition","savedStringPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedStrings","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","addExtension","floor","FLOAT32_OPTIONS","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT","roundFloat32","float32Number"],"sources":["C:/Users/Катя/Desktop/WeLearn/Frontend_WeLearn/node_modules/cbor-x/decode.js"],"sourcesContent":["let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) object[safeKey(key)] = read()\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) map.set(key, read())\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\treturn key === '__proto__' ? '__proto_' : key\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + value << BigInt(8)\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84)\n\t\tthrow new Error('Packed values structure must be followed by a 4 element array')\n\tlet newPackedValues = read() // packed values\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tthrow new Error('No support for non-integer packed references yet')\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}