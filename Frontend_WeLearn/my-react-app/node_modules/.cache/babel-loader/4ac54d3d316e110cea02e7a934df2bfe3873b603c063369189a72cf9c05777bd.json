{"ast":null,"code":"import { Encoder } from './encode.js';\nimport { Decoder } from './decode.js';\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - cbor-x Encoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function encodeIter(objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable');\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return encodeIterSync(objectIterator, options);\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return encodeIterAsync(objectIterator, options);\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise');\n  }\n}\nfunction* encodeIterSync(objectIterator, options) {\n  const encoder = new Encoder(options);\n  for (const value of objectIterator) {\n    yield encoder.encode(value);\n  }\n}\nasync function* encodeIterAsync(objectIterator, options) {\n  const encoder = new Encoder(options);\n  for await (const value of objectIterator) {\n    yield encoder.encode(value);\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - Decoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function decodeIter(bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise');\n  }\n  const decoder = new Decoder(options);\n  let incomplete;\n  const parser = chunk => {\n    let yields;\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk]);\n      incomplete = undefined;\n    }\n    try {\n      yields = decoder.decodeMultiple(chunk);\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition);\n        yields = err.values;\n      } else {\n        throw err;\n      }\n    }\n    return yields;\n  };\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return function* iter() {\n      for (const value of bufferIterator) {\n        yield* parser(value);\n      }\n    }();\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return async function* iter() {\n      for await (const value of bufferIterator) {\n        yield* parser(value);\n      }\n    }();\n  }\n}","map":{"version":3,"names":["Encoder","Decoder","encodeIter","objectIterator","options","Error","Symbol","iterator","encodeIterSync","then","asyncIterator","encodeIterAsync","encoder","value","encode","decodeIter","bufferIterator","decoder","incomplete","parser","chunk","yields","Buffer","concat","undefined","decodeMultiple","err","slice","lastPosition","values","iter"],"sources":["C:/Users/Катя/Desktop/WeLearn/Frontend_WeLearn/node_modules/cbor-x/iterators.js"],"sourcesContent":["import { Encoder } from './encode.js'\nimport { Decoder } from './decode.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - cbor-x Encoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function encodeIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return encodeIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return encodeIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * encodeIterSync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\nasync function * encodeIterAsync (objectIterator, options) {\n  const encoder = new Encoder(options)\n  for await (const value of objectIterator) {\n    yield encoder.encode(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - Decoder options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function decodeIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const decoder = new Decoder(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = decoder.decodeMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}